{"version":3,"mappings":"gDAAO,MAAMA,EAAe,CACxB,UAAW,EACX,UAAW,EACX,QAAS,EACT,eAAgB,EAChB,gBAAiB,EACjB,aAAc,EACd,aAAc,EACd,WAAY,CAChB,ECLMC,EAAc,UAKPC,EAAoB,CAAC,CAAE,IAAAC,EAAMF,CAAa,IAAMG,GAAqB,CAC9E,IAAIC,EAAK,KACLC,EAAc,GAClB,MAAMC,EAAW,OAAO,WAAY,EAC9BC,EAAY,IAAI,IAAI,OAAO,SAAS,IAAI,EAC9CA,EAAU,SAAW,GACrBA,EAAU,KAAO,GACjB,MAAMC,EAAiB,IAAM,CACzB,GAAIJ,EACA,OACJ,MAAMK,EAA2B,MACjCL,EAAK,IAAI,UAAU,GAAGK,CAAQ,MAAM,OAAO,SAAS,IAAI,mBAC7C,mBAAmBP,CAAG,CAAC,QACvB,mBAAmBK,EAAU,SAAU,EAAC,aACnC,mBAAmBD,CAAQ,CAAC,EAAE,EAC9CF,EAAG,WAAa,cAChBA,EAAG,iBAAiB,OAAQ,IAAM,CAC9BC,EAAc,EAC1B,CAAS,EACDD,EAAG,iBAAiB,QAAUM,GAAU,CACpC,QAAQ,MAAM,6BAA8BA,CAAK,CAC7D,CAAS,EACDN,EAAG,iBAAiB,UAAYM,GAAU,CACtC,MAAMC,EAAO,IAAI,WAAWD,EAAM,IAAI,EAEtC,GADoBC,EAAK,CAAC,IACNZ,EAAa,UAAW,CACxC,MAAMa,EAAU,IAAI,YACdC,EAAQD,EAAQ,OAAOD,EAAK,MAAM,EAAG,EAAE,CAAC,EACxCG,EAAS,IAAI,eAAe,CAC9B,MAAMC,EAAY,CACdX,EAAG,iBAAiB,UAAW,SAASY,EAAcN,EAAO,CACzD,MAAMC,EAAO,IAAI,WAAWD,EAAM,IAAI,EAChCO,EAAcN,EAAK,CAAC,EAG1B,GADmBC,EAAQ,OAAOD,EAAK,MAAM,EAAG,EAAE,CAAC,IAChCE,EACf,OAEJ,MAAMK,EAAUP,EAAK,MAAM,EAAE,EACzBM,IAAgBlB,EAAa,UAC7BgB,EAAW,QAAQG,CAAO,EAErBD,IAAgBlB,EAAa,UAClCgB,EAAW,MAAO,EAClBX,EAAG,oBAAoB,UAAWY,CAAa,EAE/E,CAAyB,CACJ,CACrB,CAAiB,EACKG,EAAaC,EAAwB,yBAACN,EAAQ,CAChD,WAAYO,CAChC,CAAiB,EACDlB,EAAiB,cAAcgB,CAAU,CACzD,CACA,CAAS,EACDf,EAAG,iBAAiB,QAAS,IAAM,CAC/B,QAAQ,KAAK,yDAAyD,EACtEA,EAAK,KACLC,EAAc,GACd,WAAWG,EAAgB,GAAI,CAC3C,CAAS,CACJ,EACKc,EAAW,IAAM,CACnB,GAAI,CAAClB,GAAMC,EACP,MAAM,IAAI,MAAM,+DAA+D,EAEnF,GAAI,CAACD,GAAM,CAACC,EACR,MAAM,IAAI,MAAM,4BAA4B,EAEhD,OAAOD,CACV,EACKiB,EAAqB,MAAOE,EAAIC,IAAS,CAC3C,GAAI,CACA,MAAMC,EAASH,EAAU,EACnB,CAAE,YAAAI,CAAW,EAAK,MAAMC,EAAA,4BAAAD,GAAA,aAAO,sBAAyC,EAAC,gCAAAA,CAAA,OACzEE,EAAcJ,GAAQ,KAAO,MAAME,EAAYF,CAAI,EAAI,KACvDK,EAAY,OAAO,WAAY,EAC/BC,EAAc,KAAK,UAAU,CAC/B,GAAAP,EACA,KAAMK,EACN,UAAAC,CAChB,CAAa,EAEKE,EADU,IAAI,YAAa,EACJ,OAAOD,CAAW,EACzCE,EAAU,IAAI,WAAWD,EAAa,OAAS,CAAC,EACtD,OAAAC,EAAQ,CAAC,EAAIjC,EAAa,eAC1BiC,EAAQ,IAAID,EAAc,CAAC,EAC3BN,EAAO,KAAKO,CAAO,EACZ,IAAI,QAAQ,MAAOC,EAASC,IAAW,CAC1C,MAAMpB,EAAS,IAAI,eAAe,CAC9B,MAAMC,EAAY,CACd,MAAMoB,EAAkBzB,GAAU,CAC9B,MAAMC,EAAO,IAAI,WAAWD,EAAM,IAAI,EAChCO,EAAcN,EAAK,CAAC,EAKpBC,EAAU,IAAI,YAGpB,GAFmBA,EAAQ,OAAOD,EAAK,MAAM,EAAG,EAAE,CAAC,IAEhCkB,EACf,OAGJ,MAAMX,EAAUP,EAAK,MAAM,EAAE,EAC7B,GAAIM,IAAgBlB,EAAa,aAC7BgB,EAAW,QAAQG,CAAO,UAErBD,IAAgBlB,EAAa,WAClCgB,EAAW,MAAO,EAClBU,EAAO,oBAAoB,UAAWU,CAAc,UAE/ClB,IAAgBlB,EAAa,aAAc,CAChD,MAAMqC,EAAYxB,EAAQ,OAAOM,CAAO,EACxC,IAAImB,EAAW,gBACf,GAAI,CAEAA,EADiB,KAAK,MAAMD,CAAS,EACjB,OAASC,CACjE,MAC0C,CAE1C,CACgCtB,EAAW,MAAM,IAAI,MAAMsB,CAAQ,CAAC,EACpCZ,EAAO,oBAAoB,UAAWU,CAAc,CACpF,CACyB,EACDV,EAAO,iBAAiB,UAAWU,CAAc,CACpD,CACrB,CAAiB,EACKhB,EAAaC,EAAwB,yBAACN,EAAQ,CAChD,WAAYO,CAChC,CAAiB,EACDlB,EAAiB,cAAcgB,CAAU,EACzC,GAAI,CACA,MAAMmB,EAAS,MAAMnB,EACrBc,EAAQK,EAAO,YAAY,CAC/C,OACuBC,EAAiB,CACpBL,EAAOK,CAAe,CAC1C,CACA,CAAa,CACb,OACeC,EAAG,CACN,eAAQ,MAAM,kCAAmCA,CAAC,EAC3C,IACnB,CACK,EACD,OAAAhC,EAAgB,EACTa,CACX","names":["MESSAGE_TYPE","DEFAULT_KEY","realtimeTransport","key","transportContext","ws","isConnected","clientId","clientUrl","setupWebSocket","protocol","event","data","decoder","rscId","stream","controller","streamHandler","messageType","payload","rscPayload","createFromReadableStream","realtimeCallServer","ensureWs","id","args","socket","encodeReply","__vitePreload","encodedArgs","requestId","messageData","messageBytes","message","resolve","reject","messageHandler","errorJson","errorMsg","result","rscPayloadError","e"],"ignoreList":[0,1],"sources":["../../../../../node_modules/rwsdk/dist/runtime/lib/realtime/shared.js","../../../../../node_modules/rwsdk/dist/runtime/lib/realtime/client.js"],"sourcesContent":["export const MESSAGE_TYPE = {\n    RSC_START: 0,\n    RSC_CHUNK: 1,\n    RSC_END: 2,\n    ACTION_REQUEST: 3,\n    ACTION_RESPONSE: 4,\n    ACTION_ERROR: 5,\n    ACTION_CHUNK: 6,\n    ACTION_END: 7,\n};\n","import { initClient } from \"../../client\";\nimport { createFromReadableStream } from \"react-server-dom-webpack/client.browser\";\nimport { IS_DEV } from \"../../constants\";\nimport { MESSAGE_TYPE } from \"./shared\";\nconst DEFAULT_KEY = \"default\";\nexport const initRealtimeClient = ({ key = DEFAULT_KEY, } = {}) => {\n    const transport = realtimeTransport({ key });\n    return initClient({ transport });\n};\nexport const realtimeTransport = ({ key = DEFAULT_KEY }) => (transportContext) => {\n    let ws = null;\n    let isConnected = false;\n    const clientId = crypto.randomUUID();\n    const clientUrl = new URL(window.location.href);\n    clientUrl.protocol = \"\";\n    clientUrl.host = \"\";\n    const setupWebSocket = () => {\n        if (ws)\n            return;\n        const protocol = IS_DEV ? \"ws\" : \"wss\";\n        ws = new WebSocket(`${protocol}://${window.location.host}/__realtime?` +\n            `key=${encodeURIComponent(key)}&` +\n            `url=${encodeURIComponent(clientUrl.toString())}&` +\n            `clientId=${encodeURIComponent(clientId)}`);\n        ws.binaryType = \"arraybuffer\";\n        ws.addEventListener(\"open\", () => {\n            isConnected = true;\n        });\n        ws.addEventListener(\"error\", (event) => {\n            console.error(\"[Realtime] WebSocket error\", event);\n        });\n        ws.addEventListener(\"message\", (event) => {\n            const data = new Uint8Array(event.data);\n            const messageType = data[0];\n            if (messageType === MESSAGE_TYPE.RSC_START) {\n                const decoder = new TextDecoder();\n                const rscId = decoder.decode(data.slice(1, 37)); // Extract RSC stream ID\n                const stream = new ReadableStream({\n                    start(controller) {\n                        ws.addEventListener(\"message\", function streamHandler(event) {\n                            const data = new Uint8Array(event.data);\n                            const messageType = data[0];\n                            // Extract the RSC stream ID and verify it matches\n                            const responseId = decoder.decode(data.slice(1, 37));\n                            if (responseId !== rscId) {\n                                return; // Not for this stream\n                            }\n                            const payload = data.slice(37);\n                            if (messageType === MESSAGE_TYPE.RSC_CHUNK) {\n                                controller.enqueue(payload);\n                            }\n                            else if (messageType === MESSAGE_TYPE.RSC_END) {\n                                controller.close();\n                                ws.removeEventListener(\"message\", streamHandler);\n                            }\n                        });\n                    },\n                });\n                const rscPayload = createFromReadableStream(stream, {\n                    callServer: realtimeCallServer,\n                });\n                transportContext.setRscPayload(rscPayload);\n            }\n        });\n        ws.addEventListener(\"close\", () => {\n            console.warn(\"[Realtime] WebSocket closed, attempting to reconnect...\");\n            ws = null;\n            isConnected = false;\n            setTimeout(setupWebSocket, 5000);\n        });\n    };\n    const ensureWs = () => {\n        if (!ws && isConnected) {\n            throw new Error(\"Inconsistent state: WebSocket is null but marked as connected\");\n        }\n        if (!ws || !isConnected) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        return ws;\n    };\n    const realtimeCallServer = async (id, args) => {\n        try {\n            const socket = ensureWs();\n            const { encodeReply } = await import(\"react-server-dom-webpack/client.browser\");\n            const encodedArgs = args != null ? await encodeReply(args) : null;\n            const requestId = crypto.randomUUID();\n            const messageData = JSON.stringify({\n                id,\n                args: encodedArgs,\n                requestId,\n            });\n            const encoder = new TextEncoder();\n            const messageBytes = encoder.encode(messageData);\n            const message = new Uint8Array(messageBytes.length + 1);\n            message[0] = MESSAGE_TYPE.ACTION_REQUEST;\n            message.set(messageBytes, 1);\n            socket.send(message);\n            return new Promise(async (resolve, reject) => {\n                const stream = new ReadableStream({\n                    start(controller) {\n                        const messageHandler = (event) => {\n                            const data = new Uint8Array(event.data);\n                            const messageType = data[0];\n                            // First byte is message type\n                            // Next 36 bytes (or fixed size) should be UUID as requestId\n                            // Remaining bytes are the payload\n                            // Extract the requestId from the message\n                            const decoder = new TextDecoder();\n                            const responseId = decoder.decode(data.slice(1, 37)); // Assuming UUID is 36 chars\n                            // Only process messages meant for this request\n                            if (responseId !== requestId) {\n                                return;\n                            }\n                            // The actual payload starts after the requestId\n                            const payload = data.slice(37);\n                            if (messageType === MESSAGE_TYPE.ACTION_CHUNK) {\n                                controller.enqueue(payload);\n                            }\n                            else if (messageType === MESSAGE_TYPE.ACTION_END) {\n                                controller.close();\n                                socket.removeEventListener(\"message\", messageHandler);\n                            }\n                            else if (messageType === MESSAGE_TYPE.ACTION_ERROR) {\n                                const errorJson = decoder.decode(payload);\n                                let errorMsg = \"Unknown error\";\n                                try {\n                                    const errorObj = JSON.parse(errorJson);\n                                    errorMsg = errorObj.error || errorMsg;\n                                }\n                                catch (e) {\n                                    // Use default error message\n                                }\n                                controller.error(new Error(errorMsg));\n                                socket.removeEventListener(\"message\", messageHandler);\n                            }\n                        };\n                        socket.addEventListener(\"message\", messageHandler);\n                    },\n                });\n                const rscPayload = createFromReadableStream(stream, {\n                    callServer: realtimeCallServer,\n                });\n                transportContext.setRscPayload(rscPayload);\n                try {\n                    const result = await rscPayload;\n                    resolve(result.actionResult);\n                }\n                catch (rscPayloadError) {\n                    reject(rscPayloadError);\n                }\n            });\n        }\n        catch (e) {\n            console.error(\"[Realtime] Error calling server\", e);\n            return null;\n        }\n    };\n    setupWebSocket();\n    return realtimeCallServer;\n};\n"],"file":"assets/client-C49bht95.js"}